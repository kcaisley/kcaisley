Technical Notes

10.02.2023

Using Python as an IDE for circuit dev

To help make this more manageable, I don't want or need IDE integration, Jupiter notebook, or any open source GUI applications. I just need raw Python and C++ command line software. All the viewing and editing will be done in Cadence. But the whole flow will be in a hand written Python/C++ workflow, except for the key place that I target Spectre, etc. All the post processing is done in Python. LVS and DRC aren't "in the loop", and they cause the loop to fail if there is a problem, but their output isn't needed to design the actual device.

Also, to keep it simple, digital sub components shouldn't rely on standard cells, right? Do they create digital gates with Xbase? Or do they mix between full custom and Pcells?

Finally, I won't try to use this for high-level integration. Only for blocks.

My goal is to make this run on a modern Fedora install. I will only use code that is super useful, and anything that doesn't fit my dependencies I will update and integrate.


I'm not sure how to solve the problem yet where I want my test bench to be run from python, but sometimes I need devices and stimuli that are best described in python, sometime I need them best described in Verilog-A, sometimes in Verilog, and sometimes even they are best described in native spice devices like sinusoidal sources. 

Also, often it's not just at the test bench on the perimeter, it's somewhere in the loop or in the forward signal path. This is the whole point with the design schemes discussed on Designers guide, with Top-down, Mixed-signal designs.

People who work on CocoTB will know this, and it looks like Ayan maybe know. Also, I suppose that Cppsim and Spectre may have solutions for this.


General Purpose Languages, DSLs, and Engines:

Python: Numpy, Scipy, Matplotlib, Sympy, ML libraries, Jupyter Notebooks, IPython

PyBind11/Boost Python and other binding libraries

BAG
Xbase
Laygo2

CocoTB

C++: Boost, fmt, spdlog, 
C
SPICE decks
ngSPICE
Xyce
Low level C/C++ BSIM models, now in VA
Verilog-A
Verilog
System Verilog
CLPSim (does it have Python bindings?)
Spectre
Cadence (Schematic, Layout, Waveform Viewer)

Verilator
Icarus Verilog
Magic
Klayout

Bash Script/Unix Terminal.  This is interactive!!!

CMake
Make
gcc
git
llvm

Foundary PDK
LVS Runsets
Standard Cells/PCells

LaTeX
Markdown
HTML/CSS
Pandoc


Schematic rendering tools from netlists, etc?


GPU acceleration
CUDA
CPU Clusters and GPU Clusters

Each step of the process requires deep understanding of the mathematics involved. But perhaps I should be amenable to just running the most naive elementary in un-accelerated implementations, in order to ensure I understand the core mathematics and procedure. Else I will be swamped by trying to understand too many disciplines.


24.10.2023



Analog: Noise, Distortion/Linearity, Gain(all dC) then (AC) considering bandwidth and noise band width. Placing in feedback adds complication.

Then digital:

Quantization has relationship to all of the above terms. DNL and INL leads to distortion, etc.




PyTorch, LuaTorch, Torch7, TH

LuaTorch = C code (TH) bound to Lua

Templates are a source of frustration, using D types, as they aren't type checked at compile time. So error messages can be cryptic.

Autograd on tensors

Code generation has some pros and cons:

Cons: jump to definition doesn't work
Pros: allows for more powerful meta programming in C++, beyond what templates can do. Also templates have a level of obscuring, you never are directly looking at the final output code, like you do in code generation.

Templates get better with "compsets"? (Spelling)

Manifesto: "Writing Python in C++"

"Ref/Rev? counts" in C++. Atomic vs non-atomic

CMake generates Build files, like Makefiles or Ninja Files
Also basil and buck builds exist, which also need to be changed for PyTorch

PyTorch and 'Cafe2' are mixed together, from when the projects merged.


28.02.2023

If I limit myself to low level block design, generation, and optimization, I can get away with test-benches and simulation built entirely with SPICE and python

This will eliminate the need for Verilog-A support, cadence schematic support, and will make me simulator independent.

Think about moving backwards in technology. 

My goal is to do the same design tasks that have always been done, but to do them in a more open and free manner.

Let us not forget the wisdom of our forebears.


Python
Pybind11
cmake
c++
OpenAccess Schematic, Layout, Parasitic
Spectre Netlist
YAML

ext2spice

My end goal is to minimize my effort to output ratio, and then work a normal amount, to seem like I have super powers.



I'm interested in system modeling that homogenizes across a range of time scales (like a pll), in a range of detail scales (semiconductor, analog, digital, Em, heat), using various mathematical represenations

09.03.2023

Fundamentally all modeling can be done in C or C++.

When we write code at higher levels, like in Python or in Verilog, or Verilog-A, it is typically either compiling down to binaries which are then linked against the simulator, or they are interpreted by a compiled program (ie Python) which connects back to C or C++.

21.03.2023

Julia is the perfect workspace for designing integrated circuits.

Like MatLab it has inline plotting, symbolic mathematics support, intuitive notation for mathematics (matrixes, DEQ, etc), interactivity

Like Python it has machine learning, large library support, plotting, interactivity, general purpose programming capability, REPL

Like C it has speed.


Like Verilog-A it allows arbitrary modeling of devices, but it has the benefit of extensibility to operators and primitives. Also the JIT Julia language compiler, alongside the necessary libraries, IS the interpreter for the model. This means you don't need to have some sort of division between the model and simulator. They share a representation.

I like the composability of this tool because it allows the user to dig down into understanding mathematical algorithms for their work without having to switch language (like Python bindings around C/C++ extensions). It also allows homogenous integration of other domains like EM solvers, thermal modeling, wireline channels, etc.

Most interesting chip design problems require the combination of multiple problem domains, and proprietary tools will often not be able to keep up with this.

Even within a chip, you can easily run into problems like those seen in a PLL, where you need to simultaneously consider fs-scale jitter and us-scale feedback system dynamics. Another example is modeling on-chip pixels detectors which need to be modeled at the semiconductor level, which then drive circuit-level signal processing, and then feed digital level controls and data output.

Layout generators are critical because they significantly restrict the degrees of freedom of optimization. Even though sub-65nm design are more sensitive than ever to parasitics, the range of solutions for a "good layout" is minimal, and so layout generators increasingly are able generate optimal layouts with minimal exceptions for a wide range of device sizing.
